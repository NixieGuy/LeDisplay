//PB0  column bit 
//PB1  clk
//PB3  row 1
//PB4  row 2
//PB5  row 3
//PB6  row 4      This pin will have to be changed later to use I2C
//PB12 row 5
//PB13 row 6
//PB14 row 7
//PB15 row 8

boolean displayArray[8][33] = {       //First number is vertical, second number is horizontal
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},  //Array has a padding 0 on first column
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},  //because of a mismatch with how the clock works
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  };

boolean numberArray[10][5][3] = {     //Tridimensional array array of 10 units of 5x3 dots
  {
  {0,1,0},
  {1,1,0},
  {0,1,0},
  {0,1,0},
  {1,1,1},
  },
  {
  {0,1,1},
  {1,0,1},
  {0,1,0},
  {1,0,0},
  {1,1,1},
  },
  {
  {1,1,0},
  {0,0,1},
  {0,1,1},
  {0,0,1},
  {1,1,0},
  },
  {
  {1,0,1},
  {1,0,1},
  {0,1,1},
  {0,0,1},
  {0,0,1},
  },
  {
  {1,1,1},
  {1,0,0},
  {1,1,0},
  {0,0,1},
  {1,1,0},
  },
  {
  {0,1,1},
  {1,0,0},
  {1,1,0},
  {1,0,1},
  {0,1,0},
  },
  {
  {1,1,1},
  {0,0,1},
  {0,1,0},
  {0,1,0},
  {1,0,0},
  },
  {
  {0,1,0},
  {1,0,1},
  {0,1,0},
  {1,0,1},
  {0,1,0},
  },
  {
  {0,1,0},
  {1,0,1},
  {0,1,1},
  {0,0,1},
  {0,1,0},
  },
  {
  {0,1,0},
  {1,0,1},
  {1,0,1},
  {1,0,1},
  {0,1,0},
  },
};
  
int rateOfChange = 0;         //Variable for a soft counter to activate NOT-main drawing functions, this will be changed for an interrupt.
byte changeX = 1;             //Variable for keeping track of X on mathDisplayDraw(), set to one to ignore padding 0.
byte changeY = 0;             //Variable for keeping track of Y on mathDisplayDraw().
byte numberArraySelect = 0;   //Variable to select a number in numberDisplayDraw().
byte numberDisplacement = 0;  //Variable to draw numbers in different starting positions.

void setup() {

pinMode(PB0, OUTPUT);       //Initialize all required pins to outputs.
pinMode(PB1, OUTPUT);
pinMode(PB3, OUTPUT);
pinMode(PB4, OUTPUT);
pinMode(PB5, OUTPUT);
pinMode(PB6, OUTPUT);
pinMode(PB12, OUTPUT);
pinMode(PB13, OUTPUT);
pinMode(PB14, OUTPUT);
pinMode(PB15, OUTPUT);
digitalWrite(PB0, LOW);     //Make sure their value is LOW.
digitalWrite(PB1, LOW);
digitalWrite(PB3, LOW);
digitalWrite(PB4, LOW);
digitalWrite(PB5, LOW);
digitalWrite(PB6, LOW);
digitalWrite(PB12, LOW);
digitalWrite(PB13, LOW);
digitalWrite(PB14, LOW);
digitalWrite(PB15, LOW);

}

void loop() {

displayControl();                   //calls main display drawing function.
rateOfChange++;                     //Increments soft counter.
//if (rateOfChange == 50){          //DISABLED activates function each 50 counts.
//  mathDisplayDraw();              //DISABLED Diagonal line drawing function "animation".
//  }
if (rateOfChange == 500){                                   //activates function every 500 counts. This approach is not practical anymore.
  numberDisplayDraw();                                      //Calls number drawing function, not yet using parameters, that will be next.
  numberArraySelect++;                                      //Increments number to draw next time.
    if(numberArraySelect > 9){ numberArraySelect = 0;}      //Makes sure numbers go 0 to 9 and not over.
  numberDisplacement += 4;                                  //Increments Y position for next draw by 4 dots.
    if(numberDisplacement > 29){ numberDisplacement = 0;}   //Makes sure function does not draw outside dot matrix.
  }


if (rateOfChange > 1000) {rateOfChange = 0;}                //Restarts soft counter. This will be exchanged for a timed interrupt.
}

//----- FUNCTIONS -----//

void displayControl(){

int i;
digitalWrite(PB0, HIGH);                          //A single pulse is written to the shift registers.
digitalWrite(PB1, HIGH);                          //Clock is advanced a step to "load" said pulse.
digitalWrite(PB1, LOW);                           //Clock set to 0.
digitalWrite(PB0, LOW);                           //Column pulse is turned to 0 for the remainder of the drawing function.
  for (i = 0; i < 33; i++){                       //Scans displayArray[8][33]
    digitalWrite(PB3, displayArray[0][i]);        //Loads value from displayArray[8][33]
    digitalWrite(PB4, displayArray[1][i]);
    digitalWrite(PB5, displayArray[2][i]);
    digitalWrite(PB6, displayArray[3][i]);
    digitalWrite(PB12, displayArray[4][i]);
    digitalWrite(PB13, displayArray[5][i]);
    digitalWrite(PB14, displayArray[6][i]);
    digitalWrite(PB15, displayArray[7][i]);
    digitalWrite(PB3, LOW);                     //Turns off all row pins before stepping to next row.
    digitalWrite(PB4, LOW);
    digitalWrite(PB5, LOW);
    digitalWrite(PB6, LOW);
    digitalWrite(PB12, LOW);
    digitalWrite(PB13, LOW);
    digitalWrite(PB14, LOW);
    digitalWrite(PB15, LOW);
    digitalWrite(PB1, HIGH);                    //Steps clock in shift registers for next column. Works on rising edge.
    digitalWrite(PB1, LOW);                     //Clock pin to 0.
    
  }
}

void numberDisplayDraw(){                             //Number drawing function.
  int x;                                              //Horizontal number scan variable.
  int y;                                              //Vertical number scan variable.
  for (y = 0; y < 5; y++){                            //Scanning is performed vertical first,
    for (x = 0; x < 3; x++){                          //horizontal second.
      displayArray[y + 1][x + numberDisplacement + 1] = numberArray[numberArraySelect][y][x];  //Puts a value from the number array into
    }                                                                                          //the display array, adjusted for position
  }                                                                                            //and number to display.
  
}

void mathDisplayDraw(){                                               //"math" drawing function.
  displayArray[changeY][changeX] = !displayArray[changeY][changeX];   //negates the value of whatever is in the array position.
  changeY++;                                                          //Increments Y
  changeX++;                                                          //Increments X
  if (changeY > 7){changeY = 0;}                                      //Stay in bounds of the screen for Y
  if (changeX > 33){changeX = 1;}                                     //Stay in bounds of the screen for X
  
}

//  Blank array for copy-pasting.
//  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
//  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
//  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
//  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
//  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
//  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
//  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
//  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
